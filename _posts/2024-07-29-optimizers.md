---
layout: post
title: "Optimizers"
author: "Henry Chang"
categories: journal
tags: [deeplearning]
image: optimizers/Optimizers_73_0.png
---

In [a previous post](https://henryjchang.github.io/function-approximation-with-dl) we explored using vanilla gradient descent for linear regression in the process of motivating activation functions for nonlinear function approximation. We saw that while we were able to estimate reasonable parameters, it took a while for the loss to converge due to the problem of pathological curvature.  In this post we solve the linear regression problem with Newton's method, a second-order method, and experiment with various first-order optimizers that retain the speed of gradient descent while improving convergence by using heuristics that approximate the second order methods.

# Linear Regression with Vanilla Gradient Descent: The Problem of Pathological Curvature

This first section is copied directly from the previous post.

Lets explore unconstrained optimization algorithms with some example data. We consider the case of linear regression to some random data sampled from some ground truth parameters fitting an affine function with noise added in.


```python
params = np.array([5, 2])

num_samples = 100
x = np.linspace(-10,10,num_samples)

np.random.seed(5)
noise = np.random.normal(0, 3, num_samples)
y = params[0]*x + params[1] + noise
```

## Reusable Components

Lets create some reusable components for calculating loss and taking a gradient descent step.


```python
def linear(X, w):
  return X @ w

def linear_grad(X, w):
  return X
```


```python
def mse_loss(predictions, labels):
  return np.mean((predictions - labels)**2)

def mse_loss_grad(predictions, labels):
  return 2 * (predictions - labels) / len(predictions)
```


```python
class LinearModelTrainer:
  def __init__(self, data, optimizer, num_epochs):
    self.data = data
    self.optimizer = optimizer
    self.epochs = num_epochs
    self.losses = []
    self.final_grad = None

  def train(self):
    for i in range(self.epochs):
      X = data['X']
      y = data['y']

      # Make predictions
      preds = linear(X, weights)

      # Calculate loss
      loss = mse_loss(preds, y)
      self.losses.append(loss)

      # Backpropagate
      mse_grad = einops.repeat(mse_loss_grad(preds, y), 'i -> i 1')
      lin_grad = linear_grad(X, weights)
      grad = mse_grad.transpose() @ lin_grad

      # Update weights
      self.optimizer.step(grad)

    # Keep track of final grad for observability
    self.final_grad = grad

  def get_grad(self):
    if self.final_grad is not None:
      return self.final_grad
    else:
      print("No gradients computed yet.")

  def get_losses(self):
    return self.losses
```


```python
class GradientDescentOptimizer:
  def __init__(self, weights, lr):
    self.lr = lr
    self.weights = weights
    self.iterated_weights = [weights.copy()]

  def step(self, grad):
    # Update weights
    self.weights -= einops.rearrange(self.lr * grad, 'i j -> (i j)')
    # Keep track of weights for visualization
    self.iterated_weights.append(self.weights.copy())

  def get_weights(self):
    return self.iterated_weights
```

## Optimize with Gradient Descent


```python
X = np.stack((x, np.ones_like(x)), axis=1)
data = {'X': X, 'y': y}
```


```python
# random initialization
initial_weights = np.random.rand(2)
weights = initial_weights.copy()
print(weights)
```

    [0.58937388 0.91473434]



```python
optimizer = GradientDescentOptimizer(weights, lr=0.01)
trainer = LinearModelTrainer(data, optimizer, num_epochs=50)
trainer.train()
```



    final weights:  [5.00396765 1.77940355]
    final grads:  [[ 2.42028619e-14 -1.01068650e+00]]




<img src="/assets/img/optimizers/Optimizers_19_0.png">


    
<img src="/assets/img/optimizers/Optimizers_20_0.png">    


With a learning rate of 0.01 and 30 epochs we find that once we enter the trough of the loss landscape the step size drastically decreases. This is the problem of pathological curvature.

![pathological_curvature.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAWwAAADiCAYAAABqUv2lAAABVGlDQ1BJQ0MgUHJvZmlsZQAAKJFtkD1LQnEUxn+WItjr0BI4uEQl9oIWNGpCETiIGb3Qcr2ZRr5croq1FU1Fc0tLUx8gCtegpT2o6AvUnOBScjt/rczqwOH8eHg4PDzQYdcMI2MHsrmiGZuf9aysrnmcLzhx42ICn6YXjFA0GhELX7d9avfY1L0bU798r8/De/uhq6Ohat4xdxD8628b10ayoMt9l/XqhlkE24hwtFw0FO8ID5gSSvhYcarJZ4oTTb5seOKxsPCtcL+e1jaEH4V9iR966gdnMyX9M4NK353MLS3K7ZV1E2EOP1PECTAt3fzvnWp4w+Qx2MVkixRpingIiWKQISm8QA6dcXzCfibVX9Xx7+5aWskLQdXzdktblxQXg9B32NKGytBzCjczhmZq343aavbCZsDf5K4KOE4sq7oMzlGoP1jWW8Wy6ufQ+QTXtQ+skmBV/9DCQAAAAFZlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA5KGAAcAAAASAAAARKACAAQAAAABAAABbKADAAQAAAABAAAA4gAAAABBU0NJSQAAAFNjcmVlbnNob3Q0b98OAAAB1mlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNi4wLjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDxleGlmOlBpeGVsWURpbWVuc2lvbj4yMjY8L2V4aWY6UGl4ZWxZRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+MzY0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6VXNlckNvbW1lbnQ+U2NyZWVuc2hvdDwvZXhpZjpVc2VyQ29tbWVudD4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+Cq5cajAAAEAASURBVHgB7Z0FnBxV8sdrNiH4n5Dg5IK7O4SDhKB3uOWCu1twONw9uLtDcPfgJMGdkJAjuCVABBJgd9+/vrXpYXYyPTvS3WOvPp/e7el+/aS6u/q9kl+lnJJ48hzwHPAcqFMO/PXXXzJp0iTbJk+eLM3NzfLnn38Kx4OtU6dOkkqlpKmpyf4H+/xeeumlq4YznaumJ74jngOeA54DZXLgq6++kueff15efvll+eSTT+Tzzz83QT3//PPLwgsvLIsuuqjMNddcts0999wyzzzzCP+nm266MltO5vKUn2Enw2jfiueA50D0HJg4caLceeed8tJLL8kbb7whY8aMkRVXXFF69eolK6ywgiy77LKywAILRN9whWr0ArtCjPfNeg54DpTGAdQbd9xxhzzwwAPy9NNPS58+faRv377Su3dvWWONNUqrtEau8gK7Rm6U76bnQKNzYMiQIXL55ZfLPffcI2uvvbZsscUW8p///Edmm222hmGN12E3zK32A/UcqE0OIKCvvvpqGT58uOy8887y5Zdfypxzzlmbgymz115gl8lAf7nngOdAPBx45pln5NRTT5XffvtN9txzT9l///3jaaiGavUCu4Zulu+q50AjcGDUqFFy/PHHm6fHEUccIQMGDGiEYRc0xqaCSvlCngOeA54DCXAAHfXyyy9vrnb/+9//vLDO4rmfYWcxxP/0HPAcSJ4DeH7svvvu8tFHH8mjjz5qHh/J96L6W/Qz7Oq/R76HngN1zYG33npLlltuOZlxxhnl/fff98I6z932AjsPc/wpzwHPgXg58Pjjj8tGG20k++yzj1x33XXxNlYHtXuVSB3cxDiHANbCZ599Jl988YW5UxH6+/XXX8u3334r//d//yddu3ZNb7POOqvtE+bbpUsXmWaaaaSLbtNM2V9ttdXi7Kqvu8Y4cOONN8ree+8tN9xwg+y000411vvKdNcHzlSG71Xb6q+//iqDBw+2UF8CFd58801ZcsklDYdh8cUXlyWWWMLAcFjCApjjyXOgFA7cd9995lNNtOIGG2xQShUNeY0X2A1529sPGoCcu+66Sx5++GF57733DIuBEN+11lpL1ltvPZlhhhnaX1Bn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OeA54DkQOQe8wI6cpb5CzwHPAc+BeDjgBXY8fPW1eg54DngORM4BL7AjZ6mv0HPAc8BzIB4OeIEdD199rZ4DngOeA5FzoK4E9uTJk2XcuHGh2x9//CGtra3y0EMPycSJEyNnZqkVOufk008/LelyxvPJJ5/I0KFDhfGXS19++aW8+OKLJVfzxhtvlDyWsEa5Vw888IDAp6gpzroz+8qz99RTT8lff/2VedjvR8yBX375RZ4fPDhda/bv9Ila3dGXoG7o2WefdUsssQRvtVtkkUXcFltsYdt6661nx4488kj3zDPP2L6+PBUf959//uluvvlmt/TSS7v+/fsX1Z/m5mZ36qmnujnmmMPtvffejrEx5q233tqNHTOmqLoyC1PXLLPM4vRDkHm44H36sPHGGxdcvpCCd955p92zN998s5DiRZWJs+6gIzxz8IXnUicUwWH/P2IOXHbZZfbsLrfcclZz9u+Im6tIdcxa6oqOO+44ezF4STLpuuuuc1dddZWbNGmSG/zccyULpMw6y91/55133E033WT9Pf3004uqDgGPAPj444/T1/3+++8m/Oebbz7366+/po/n2/noo4/cI488ki7y/fffu3IE4wcffOC++OKLdH2l7px11lnpS3XlYPespaUlfSyqnTjrzuzjlVde6QV2JkNi2t92221dILBpIvt3TM0mVm1dqURY5bCkh3TWav/5o0JaNt98c9HZp0w33XSydu/ekkql0ufZUWFQ0pKb66DspW72byuU9Wf55ZeXFVZYwY5m9jer2FQ/9WMkd911lxx66KGiK4r0+emnn14uuugiUYEpJ554Yvp40Ed9qmycwYmfx44VXYXId999FxySOeecU+hXJgXXcyxzP9dvxjHvvPNmXt7hfjavLr/8crn00kvT10077bSyTt++6d+ZO9n9Cc4Fx4P/wfHs/7nqDq6BX6icCqHsMWRfQzu5iDbYsimz7aA/2WU6ajMoH1yfWWdwLvivq71gN/0/uC6znVzHggsK5VVQvtz/mf0K6uIdyKTs38G5XNcG56r5f90J7A8//FB0SS9zzTVXmu/9+vWzfZ05is5MZfXVV0+fQ4e53XbbmUCfddZZZcMNN5RDDjlEXn75ZRPwCB+dCcv7778v66yzjgmjr776Sq6//npZf/31ZZdddpG11lpLZp99dvswPPHEE3Z8qaWWkjXX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)

Instead of following the gradient down the trough, the loss bounces down the sides of the trough.

How can we avoid getting stuck in the trough? The gradients we use are bouncing along the sides of the trough. Instead of reducing the learning rate, which would reduce the amount of bouncing but simultaneously make the step sizes too small, we can leverage knowledge of the curvature of the loss function. We'll explore a powerful method that does just that next.

# Newton's Method

A popular optimization technique for taking the second derivative into account is Newton's Method. Recall that a function can be approximated to the nth order with its Taylor approximation. A 2nd order Taylor expansion of a function would be:

$ f(x + Δt) ≈ f(x) + f'(x)Δt + f''(x) \frac{Δt^{2}}{2}$

To find the $Δt$ that minimizes the above approximation, we can take the derivative w.r.t. $Δt$ and set it equal to zero:

$ 0 = \frac{d (f(x) + f'(x)Δt + f''(x) \frac{Δt^{2}}{2})}{d \Delta t} = f'(x) + f''(x) Δt$

So $Δt = -\frac{f'(x)}{f''(x)}$

So now the parameter update would be
$w_{k+1} = w_k + α Δt = w_k - α \frac{f'(x)}{f''(x)}$

where $α$ is the learning rate.

Recall in the case of linear regression with MSE loss, our loss function is
$L(x) = \frac{1}{n} ∑_{i=1}^{n}(f(x) - y)^2)$ and model is $f(p) = p_0x + p_1$.

$\frac{dL}{\partial p_i} = \frac{2}{n} ∑_{m=1}^{n}(f(p) - y)\frac{df}{dp_i}$

$\frac{d^2L}{\partial p_i \partial p_j} = \frac{2}{n} ∑_{m=1}^{n}\frac{\partial f}{\partial p_i}\frac{\partial f}{\partial p_j} + (f(p) - y)\frac{\partial^2 f}{\partial p_i \partial p_j}$

So taking the partial derivatives, we find our Hessian matrix is
$\frac{2}{n}\sum_{i=1}^n\begin{bmatrix}x_i^2 & x_i\\x_i & 1\end{bmatrix}$


Lets add the Hessian for our overall function to optimize.


```python
def mse_linear_hessian(predictions, labels, X):
  x = X[:,0]
  n = len(x)
  mat = np.array([[x*x, x], \
                  [x,   np.ones_like(x)]])
  return 2 * np.mean(mat, axis=2)
```


```python
class NewtonOptimizer:
  def __init__(self, weights, lr):
    self.lr = lr
    self.weights = weights
    self.iterated_weights = [weights.copy()]

  def step(self, grad, hessian):
    # Update weights
    grad = grad.reshape(-1,1)
    hessian_inv = np.linalg.inv(hessian)
    self.weights -= self.lr * (hessian_inv @ grad).reshape(-1)
    # Keep track of weights for visualization
    self.iterated_weights.append(self.weights.copy())

  def get_weights(self):
    return self.iterated_weights
```

We now need to compute the Hessian as part of the backpropagation step of our trainer:


```python
class LinearModelTrainerWithHessian:
  def __init__(self, data, optimizer, num_epochs):
    self.data = data
    self.optimizer = optimizer
    self.epochs = num_epochs
    self.losses = []
    self.final_grad = None

  def train(self):
    for i in range(self.epochs):
      X = data['X']
      y = data['y']

      # Make predictions
      preds = linear(X, weights)

      # Calculate loss
      loss = mse_loss(preds, y)
      self.losses.append(loss)

      # Backpropagate
      mse_grad = einops.repeat(mse_loss_grad(preds, y), 'i -> i 1')
      lin_grad = linear_grad(X, weights)
      grad = mse_grad.transpose() @ lin_grad
      hessian = mse_linear_hessian(preds, y, X) # needed for Newton's method

      # Update weights
      self.optimizer.step(grad, hessian)

    # Keep track of final grad for observability
    self.final_grad = grad

  def get_grad(self):
    if self.final_grad is not None:
      return self.final_grad
    else:
      print("No gradients computed yet.")

  def get_losses(self):
    return self.losses
```



With Newton's Method, since we can leverage the curvature information we are much less likely to overshoot - we can increase the learning rate.


```python
optimizer = NewtonOptimizer(weights, lr=0.1)
trainer = LinearModelTrainerWithHessian(data, optimizer, num_epochs=50)
trainer.train()
```

    
<img src="/assets/img/optimizers/Optimizers_38_0.png">
    



    
<img src="/assets/img/optimizers/Optimizers_39_0.png">
    


Notice at each iteration the weights move much more directly toward the minimum. In fact, for this example, the 2nd order Taylor expansion is exactly equivalent to the original loss function. So we don't need to recompute a new 2nd order approximation around the current point at each iteration; instead, we can can get away with increasing the learning rate to 1.0 and get to the minimum in one iteration:




    
<img src="/assets/img/optimizers/Optimizers_41_1.png">
    


This is great! Newton's method is really powerful. Why don't we use it for all our optimization problems?

Notice that the backpropagation step requires taking the 2nd derivatives with respect to parameters across layers. If there are $n$ parameters, the Hessian is of size $n^2$. In modern deep neural networks, there can be billions of parameters - the square of that many parameters is too many parameters to handle. Inverting the Hessian is also computationally expensive.

What can we do instead? There are a number of optimizers that approximate Newton's method without needing to compute a Hessian. We'll explore those next.

# Momentum

The momentum optimizer uses past gradient information as a heuristic for taking curvature information into account - it accumulates the change in gradients so far. It adds a decayed amount of past gradients to the current gradient such that oscillatory terms are cancelled out and terms in the same direction build on each other.

$σ_{i} = g_{i} + λσ_{i-1}$

$δ_{i} = -γσ_{i}$

$w_{i} = w_{i-1} + \delta_{i}$

where $g_i$ is the gradient at the current time step, $λ$ is the decay rate applied to past gradient sums, and $σ_i$ is the current gradient sum. $γ$ is the learning rate and $w$ is the set of parameters to update.


```python
class MomentumOptimizer:
  def __init__(self, weights, lr, decay_rate):
    self.lr = lr
    self.decay_rate = decay_rate
    self.weights = weights
    self.iterated_weights = [weights.copy()]
    self.grad_sum = np.zeros_like(weights)

  def step(self, grad):
    # Update weights
    self.grad_sum = self.decay_rate * self.grad_sum + grad
    self.weights -= einops.rearrange(self.lr * self.grad_sum, 'i j -> (i j)')

    # Keep track of weights for visualization
    self.iterated_weights.append(self.weights.copy())

  def get_weights(self):
    return self.iterated_weights
```


```python
weights = initial_weights.copy()
optimizer = MomentumOptimizer(weights, lr=0.01, decay_rate=0.5)
trainer = LinearModelTrainer(data, optimizer, num_epochs=50)
trainer.train()
```



    
<img src="/assets/img/optimizers/Optimizers_48_0.png">
    



    
<img src="/assets/img/optimizers/Optimizers_49_0.png">
    


Notice the weights after the first iteration are identical to those from vanilla gradient descent. However, after that step, the previous gradient information start to accumulate. This gives the effect of a ball rolling down the loss landscape. An additional benefit of momentum is that for a nonconvex loss landscape, it gives some possibility of escaping local minima if there is enough momentum.

# AdaGrad

AdaGrad is short for Adaptive Gradient. Instead of keeping track of the sum of gradients, it instead keeps track of the sum of gradients squared. This sum of gradients squared acts as an approximation of the Hessian. The update rule should look the same as Newton's method if $\sqrt\sigma_i$ is replaced with $H_i$.

$σ_i = g_i^2 + \sigma_{i-1}$

$\delta_i = -\gamma \frac{g_i}{\sqrt\sigma_i}$

$w_i = w_{i-1} + \delta_i$

AdaGrad chooses to update less in directions that have already been explored, helping to avoid getting stuck at saddle points.


```python
class AdaGradOptimizer:
  def __init__(self, weights, lr):
    self.lr = lr
    self.weights = weights
    self.iterated_weights = [weights.copy()]
    self.grad_sq_sum = np.zeros_like(weights).reshape(1,-1)

  def step(self, grad):
    # Update weights
    self.grad_sq_sum += grad**2
    self.weights -= einops.rearrange(self.lr * grad/np.sqrt(self.grad_sq_sum), 'i j -> (i j)')

    # Keep track of weights for visualization
    self.iterated_weights.append(self.weights.copy())

  def get_weights(self):
    return self.iterated_weights
```


```python
weights = initial_weights.copy()
optimizer = AdaGradOptimizer(weights, lr=0.5)
trainer = LinearModelTrainer(data, optimizer, num_epochs=50)
trainer.train()
```


    
<img src="/assets/img/optimizers/Optimizers_56_0.png">
    


    
<img src="/assets/img/optimizers/Optimizers_57_0.png">
    


Note that we had to really bump up the learning rate to converge in a reasonable amount of time. The next optimizer will address this deficiency.

# RMSProp

RMSProp, short for Root Mean Squared Propagation, addresses the slowness of AdaGrad by decaying the sum of squared gradients such that the denominator of the term contributing to $\delta$ doesn't necessarily always increase.

$σ_i = (1-\lambda)g_i^2 + λ\sigma_{i-1}$

$\delta_i = -\gamma \frac{g_i}{\sqrt\sigma_i}$

$w_i = w_{i-1} + \delta_i$


```python
class RMSPropOptimizer:
  def __init__(self, weights, lr, decay_rate):
    self.lr = lr
    self.weights = weights
    self.iterated_weights = [weights.copy()]
    self.grad_sq_sum = np.zeros_like(weights).reshape(1,-1)
    self.decay_rate = decay_rate

  def step(self, grad):
    # Update weights
    self.grad_sq_sum = (1 - self.decay_rate) * grad**2 + self.decay_rate * self.grad_sq_sum
    self.weights -= einops.rearrange(self.lr * grad/np.sqrt(self.grad_sq_sum), 'i j -> (i j)')

    # Keep track of weights for visualization
    self.iterated_weights.append(self.weights.copy())

  def get_weights(self):
    return self.iterated_weights
```


```python
weights = initial_weights.copy()
optimizer = RMSPropOptimizer(weights, lr=0.1, decay_rate=0.99)
trainer = LinearModelTrainer(data, optimizer, num_epochs=50)
trainer.train()
```



<img src="/assets/img/optimizers/Optimizers_64_0.png">
    


    
<img src="/assets/img/optimizers/Optimizers_65_0.png">
    


Note the trajectory taken by RMSProp is very similar to that of AdaGrad. However we were able to achieve a better result in the same number of epochs with a lower learning rate. This was possible because we didn't allow the sum of squared gradients to grow unbounded - it was slightly decayed at each iteration, adding on a tiny amount of the current gradient squared.

# Adam

Finally, Adam, short for Adaptive Moment Estimation, combines the effects of Momentum and RMSProp. It's typically the go-to optimizer for training deep neural networks.

$\mu_{i} = (1-\lambda_1)g_{i} + λ_1\mu_{i-1}$

$σ_i = (1-\lambda_2)g_i^2 + λ_2\sigma_{i-1}$

$\delta_i = -\gamma \frac{\mu_i}{\sqrt\sigma_i}$

$w_i = w_{i-1} + \delta_i$


```python
class AdamOptimizer:
  def __init__(self, weights, lr, decay_rate_grad, decay_rate_grad_sq):
    self.lr = lr
    self.weights = weights
    self.iterated_weights = [weights.copy()]
    self.grad_sq_sum = np.zeros_like(weights).reshape(1,-1)
    self.decay_rate_grad = decay_rate_grad
    self.decay_rate_grad_sq = decay_rate_grad_sq
    self.grad_sum = np.zeros_like(weights).reshape(1,-1)
    self.grad_sq_sum = np.zeros_like(weights).reshape(1,-1)

  def step(self, grad):
    # Update weights
    self.grad_sum = (1 - self.decay_rate_grad) * grad + self.decay_rate_grad * self.grad_sum
    self.grad_sq_sum = (1 - self.decay_rate_grad_sq) * grad**2 + self.decay_rate_grad_sq * self.grad_sq_sum
    self.weights -= einops.rearrange(self.lr * self.grad_sum/np.sqrt(self.grad_sq_sum), 'i j -> (i j)')

    # Keep track of weights for visualization
    self.iterated_weights.append(self.weights.copy())

  def get_weights(self):
    return self.iterated_weights
```


```python
weights = initial_weights.copy()
optimizer = AdamOptimizer(weights, lr=0.1, decay_rate_grad=0.9, decay_rate_grad_sq=0.99)
trainer = LinearModelTrainer(data, optimizer, num_epochs=50)
trainer.train()
```

    
<img src="/assets/img/optimizers/Optimizers_72_0.png">

    

    
<img src="/assets/img/optimizers/Optimizers_73_0.png">
    


Adam has two decay rate parameters to tune. It combines the speed of momentum with the ability to change directions from RMSProp. Depending on how the hyperparameters are chosen, the trajectory from Adam can vary quite a bit.

# References


https://blog.paperspace.com/intro-to-optimization-momentum-rmsprop-adam/

https://towardsdatascience.com/a-visual-explanation-of-gradient-descent-methods-momentum-adagrad-rmsprop-adam-f898b102325c

https://www.cs.toronto.edu/~jmartens/docs/Deep_HessianFree.pdf

